import { ConstrPlutusData, PlutusData, PlutusList, PlutusMap } from '../../src';
import { HexBlob } from '@cardano-sdk/util';

describe('PlutusData', () => {
  describe('Integer', () => {
    it('can encode a positive integer', () => {
      const data = PlutusData.newInteger(5n);
      expect(HexBlob.fromBytes(data.toBytes())).toEqual('05');
    });

    it('can encode a negative integer', () => {
      const data = PlutusData.newInteger(-5n);
      expect(HexBlob.fromBytes(data.toBytes())).toEqual('24');
    });

    it('can encode an integer bigger than unsigned 64bits', () => {
      const data = PlutusData.newInteger(18_446_744_073_709_551_616n);
      expect(HexBlob.fromBytes(data.toBytes())).toEqual('c249010000000000000000');
    });

    it('can encode a negative integer bigger than unsigned 64bits', () => {
      const data = PlutusData.newInteger(-18_446_744_073_709_551_616n);
      expect(HexBlob.fromBytes(data.toBytes())).toEqual('3bffffffffffffffff');
    });

    it('can decode a positive integer', () => {
      const data = PlutusData.fromBytes(Buffer.from('05', 'hex'));
      expect(data.asInteger()).toEqual(5n);
    });

    it('can decode a negative integer', () => {
      const data = PlutusData.fromBytes(Buffer.from('24', 'hex'));
      expect(data.asInteger()).toEqual(-5n);
    });

    it('can decode an integer bigger than unsigned 64bits', () => {
      const data = PlutusData.fromBytes(Buffer.from('c249010000000000000000', 'hex'));
      expect(data.asInteger()).toEqual(18_446_744_073_709_551_616n);
    });

    it('can decode a negative integer bigger than unsigned 64bits', () => {
      const data = PlutusData.fromBytes(Buffer.from('3bffffffffffffffff', 'hex'));
      expect(data.asInteger()).toEqual(-18_446_744_073_709_551_616n);
    });
  });

  describe('Bytes', () => {
    it('can encode a small byte string (less than 64 bytes)', () => {
      const data = PlutusData.newBytes(new Uint8Array([0x01, 0x02, 0x03, 0x04, 0x05, 0x06]));
      expect(HexBlob.fromBytes(data.toBytes())).toEqual('46010203040506');
    });

    it('can decode a small byte string (less than 64 bytes)', () => {
      const data = PlutusData.fromBytes(Buffer.from('46010203040506', 'hex'));
      expect(HexBlob.fromBytes(data.asBoundedBytes()!)).toEqual('010203040506');
    });

    it('can encode a big byte string (more than 64 bytes)', () => {
      const payload = new Uint8Array([
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08
      ]);

      const data = PlutusData.newBytes(payload);
      expect(HexBlob.fromBytes(data.toBytes())).toEqual(
        '5f584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708ff'
      );
    });

    it('can decode a big byte string (more than 64 bytes)', () => {
      const payload = [
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
        0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02,
        0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x01, 0x02, 0x03, 0x04,
        0x05, 0x06, 0x07, 0x08
      ];

      const data = PlutusData.fromBytes(
        Buffer.from(
          '5f584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708584001020304050607080102030405060708010203040506070801020304050607080102030405060708010203040506070801020304050607080102030405060708ff',
          'hex'
        )
      );
      expect([...data.asBoundedBytes()!]).toEqual(payload);
    });
  });

  describe('List', () => {
    it('can encode simple plutus list', () => {
      const data = new PlutusList();

      data.add(PlutusData.newInteger(1n));
      data.add(PlutusData.newInteger(2n));
      data.add(PlutusData.newInteger(3n));
      data.add(PlutusData.newInteger(4n));
      data.add(PlutusData.newInteger(5n));

      expect(HexBlob.fromBytes(data.toBytes())).toEqual('9f0102030405ff');
    });

    it('can encode a list of plutus list', () => {
      const innerList = new PlutusList();

      innerList.add(PlutusData.newInteger(1n));
      innerList.add(PlutusData.newInteger(2n));
      innerList.add(PlutusData.newInteger(3n));
      innerList.add(PlutusData.newInteger(4n));
      innerList.add(PlutusData.newInteger(5n));

      const outer = new PlutusList();

      outer.add(PlutusData.newInteger(1n));
      outer.add(PlutusData.newInteger(2n));
      outer.add(PlutusData.newList(innerList));
      outer.add(PlutusData.newList(innerList));
      outer.add(PlutusData.newInteger(5n));

      expect(HexBlob.fromBytes(outer.toBytes())).toEqual('9f01029f0102030405ff9f0102030405ff05ff');
    });
  });

  describe('Map', () => {
    it('can encode simple plutus map', () => {
      const data = new PlutusMap();

      data.insert(PlutusData.newInteger(1n), PlutusData.newInteger(2n));

      expect(HexBlob.fromBytes(data.toBytes())).toEqual('a10102');
    });
  });

  describe('Constr', () => {
    it('can encode simple Constr', () => {
      const args = new PlutusList();
      args.add(PlutusData.newInteger(1n));
      args.add(PlutusData.newInteger(2n));
      args.add(PlutusData.newInteger(3n));
      args.add(PlutusData.newInteger(4n));
      args.add(PlutusData.newInteger(5n));

      const data = new ConstrPlutusData(0n, args);

      expect(HexBlob.fromBytes(data.toBytes())).toEqual('d8799f0102030405ff');
    });
  });
});
